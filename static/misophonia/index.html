<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Shader Renderer & Control Panel</title>
    <style>
        /* Base styles and layout */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        #main-container {
            display: flex;
            flex-wrap: wrap;
        }

        /* Left Panel: Control Panel */
        #left-panel {
            width: 25%;
            padding-right: 20px;
            box-sizing: border-box;
            border-right: 1px solid #ccc;
        }

        /* Right Panel: Canvas Settings & Renderer */
        #right-panel {
            width: 75%;
            padding-left: 20px;
            box-sizing: border-box;
        }

        /* Canvas settings, folder upload container */
        #canvas-settings,
        #folder-upload-container {
            margin-bottom: 10px;
        }

        #canvas-settings label,
        #folder-upload-container label {
            margin-right: 10px;
        }

        /* Canvas: No fixed CSS sizeâ€”inline styles determine display dimensions */
        #shader-canvas {
            border: 1px solid #ccc;
            display: block;
        }

        /* Control Panel Styles */
        .control {
            margin-bottom: 15px;
        }

        .control label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
        }

        /* XY Plane control styling */
        .xy-plane {
            border: 1px solid #ccc;
            width: 200px;
            height: 200px;
            position: relative;
            margin-top: 5px;
            background: #f0f0f0;
            cursor: crosshair;
        }

        .xy-indicator {
            width: 10px;
            height: 10px;
            background: red;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
        }
    </style>
</head>

<body>
    <h1>Shader Renderer & Control Panel</h1>
    <div id="main-container">
        <!-- Left Panel: Controls -->
        <div id="left-panel">
            <h2>Controls</h2>
            <div id="controls-container"></div>
        </div>
        <!-- Right Panel: Canvas Settings, Folder Upload, and Renderer -->
        <div id="right-panel">
            <div id="canvas-settings">
                <label for="canvas-width">Canvas Width:</label>
                <input id="canvas-width" type="number" value="800" min="100" max="2000">
                <label for="canvas-height">Canvas Height:</label>
                <input id="canvas-height" type="number" value="600" min="100" max="2000">
                <button id="update-canvas-dimensions">Update Dimensions</button>
            </div>
            <div id="folder-upload-container">
                <label for="folder-upload">Upload Folder (with JSON schema & GLSL shader):</label>
                <!-- The webkitdirectory attribute enables directory selection in supported browsers -->
                <input type="file" id="folder-upload" webkitdirectory directory multiple>
            </div>
            <canvas id="shader-canvas"></canvas>
        </div>
    </div>

    <script>
        /***********************************
         * Global Setup & Utility Functions
         ***********************************/
        const canvas = document.getElementById('shader-canvas');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert("WebGL is not supported by your browser.");
        }

        // Object to store custom uniform values from the control panel
        let customUniforms = {};

        // Convert hex color string to normalized RGB array
        function hexToRgb(hex) {
            hex = hex.replace(/^#/, '');
            if (hex.length === 3) {
                hex = hex.split('').map(x => x + x).join('');
            }
            const intVal = parseInt(hex, 16);
            return [
                ((intVal >> 16) & 255) / 255,
                ((intVal >> 8) & 255) / 255,
                (intVal & 255) / 255
            ];
        }

        // (Optional) A smoothstep helper if needed in controls calculations.
        function smoothstep(edge0, edge1, x) {
            // Scale, bias and saturate x to 0..1 range
            x = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
            // Evaluate polynomial
            return x * x * (3 - 2 * x);
        }

        /******************************
         * Canvas Dimension Management
         ******************************/
        function updateCanvasDimensions() {
            const widthInput = document.getElementById('canvas-width');
            const heightInput = document.getElementById('canvas-height');
            const width = parseInt(widthInput.value, 10);
            const height = parseInt(heightInput.value, 10);
            if (!isNaN(width) && !isNaN(height)) {
                // Set both internal resolution and inline CSS styles
                canvas.width = width;
                canvas.height = height;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
        }
        document.getElementById('update-canvas-dimensions')
            .addEventListener('click', updateCanvasDimensions);
        updateCanvasDimensions(); // Initialize dimensions on load

        /***************************
         * Shader Renderer Setup
         ***************************/
        // Vertex shader for a full-screen quad
        const vertexShaderSource = `
      attribute vec2 a_position;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;

        // Default fragment shader using u_time and u_resolution
        let fragmentShaderSource = `
      #ifdef GL_ES
      precision mediump float;
      #endif
      uniform float u_time;
      uniform vec2 u_resolution;
      void main(void) {
        vec2 uv = gl_FragCoord.xy / u_resolution;
        uv = uv - 0.5;
        uv.x *= u_resolution.x / u_resolution.y;
        float dist = length(uv);
        float wave = sin(dist * 10.0 - u_time * 3.0);
        float intensity = smoothstep(0.3, 0.0, abs(wave));
        vec3 color = mix(vec3(0.2, 0.1, 0.5), vec3(1.0, 0.8, 0.3), intensity);
        gl_FragColor = vec4(color, 1.0);
      }
    `;

        let shaderProgram = null;
        let timeLocation = null;
        let resolutionLocation = null;

        // Compile shader from source
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error("Shader compile error:", gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Link vertex and fragment shaders into a program
        function createProgram(gl, vertexSource, fragmentSource) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
            if (!vertexShader || !fragmentShader) return null;
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error("Program linking error:", gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        // Initialize default shader program and fetch uniform locations
        shaderProgram = createProgram(gl, vertexShaderSource, fragmentShaderSource);
        if (!shaderProgram) {
            console.error("Failed to initialize the shader program.");
        }
        function updateUniformLocations() {
            timeLocation = gl.getUniformLocation(shaderProgram, 'u_time');
            resolutionLocation = gl.getUniformLocation(shaderProgram, 'u_resolution');
        }
        updateUniformLocations();

        // Setup full-screen quad geometry
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        // Update custom uniforms from control panel values
        function updateCustomUniforms() {
            for (let name in customUniforms) {
                const value = customUniforms[name];
                const loc = gl.getUniformLocation(shaderProgram, name);
                if (loc === null) continue;
                if (typeof value === 'number') {
                    gl.uniform1f(loc, value);
                } else if (typeof value === 'boolean') {
                    gl.uniform1i(loc, value ? 1 : 0);
                } else if (typeof value === 'object' && value !== null && 'x' in value && 'y' in value) {
                    gl.uniform2f(loc, value.x, value.y);
                } else if (typeof value === 'string') {
                    if (value.startsWith('#')) { // treat as color
                        const rgb = hexToRgb(value);
                        gl.uniform3f(loc, rgb[0], rgb[1], rgb[2]);
                    } else {
                        gl.uniform1f(loc, parseFloat(value) || 0);
                    }
                }
            }
        }

        // Main render loop: update uniforms and draw the full-screen quad
        function render(time) {
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.useProgram(shaderProgram);
            if (timeLocation) gl.uniform1f(timeLocation, time * 0.001);
            if (resolutionLocation) gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            updateCustomUniforms();
            const positionLocation = gl.getAttribLocation(shaderProgram, "a_position");
            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);

        /**************************************************
         * Directory (Folder) Upload: Shader & Control Schema
         **************************************************/
        // When a folder is selected, process its files to find one JSON and one GLSL file.
        document.getElementById('folder-upload').addEventListener('change', handleFolderUpload);

        function handleFolderUpload(event) {
            const files = event.target.files;
            let schemaFile = null;
            let shaderFile = null;
            // Iterate over all files in the selected directory.
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const name = file.name.toLowerCase();
                if (name.endsWith('.json')) {
                    schemaFile = file;
                } else if (name.endsWith('.glsl') || name.endsWith('.frag') || name.endsWith('.txt')) {
                    shaderFile = file;
                }
            }
            if (!schemaFile) {
                console.error("No JSON schema file found in the directory.");
                return;
            }
            if (!shaderFile) {
                console.error("No GLSL shader file found in the directory.");
                return;
            }
            let newSchemaData = null;
            let newShaderSource = null;

            // Read and parse the JSON schema file.
            const schemaReader = new FileReader();
            schemaReader.onload = function (e) {
                try {
                    newSchemaData = JSON.parse(e.target.result);
                } catch (err) {
                    console.error("Error parsing JSON schema:", err);
                }
                checkAndApply();
            };
            schemaReader.readAsText(schemaFile);

            // Read the GLSL shader file.
            const shaderReader = new FileReader();
            shaderReader.onload = function (e) {
                newShaderSource = e.target.result;
                checkAndApply();
            };
            shaderReader.readAsText(shaderFile);

            // When both files are read, update shader and control panel.
            function checkAndApply() {
                if (newSchemaData && newShaderSource) {
                    // Update the fragment shader source and reinitialize the shader program.
                    fragmentShaderSource = newShaderSource;
                    const newProgram = createProgram(gl, vertexShaderSource, fragmentShaderSource);
                    if (newProgram) {
                        shaderProgram = newProgram;
                        updateUniformLocations();
                        console.log("Shader updated from folder successfully!");
                    } else {
                        console.error("Failed to compile shader from folder.");
                    }
                    // Update the control panel using the new JSON schema.
                    const controlsContainer = document.getElementById('controls-container');
                    controlsContainer.innerHTML = "";
                    renderControls(newSchemaData);
                }
            }
        }

        /***************************************
         * Control Panel Setup & Rendering
         ***************************************/
        // Default control schema (in case no folder is loaded)
        const defaultControlSchema = {
            "controls": [
            ]
        };

        // Render controls based on the provided schema.
        function renderControls(schema) {
            const container = document.getElementById('controls-container');
            schema.controls.forEach(control => {
                const controlDiv = document.createElement('div');
                controlDiv.className = 'control';
                const label = document.createElement('label');
                label.textContent = control.label;
                controlDiv.appendChild(label);
                let inputElement;
                // Initialize uniform value.
                customUniforms[control.uniform] = control.default;
                // Create input element based on control type.
                switch (control.type) {
                    case 'knob':
                    case 'slider':
                        inputElement = document.createElement('input');
                        inputElement.type = 'range';
                        inputElement.min = control.min;
                        inputElement.max = control.max;
                        inputElement.step = control.step;
                        inputElement.value = control.default;
                        inputElement.addEventListener('input', (e) => {
                            customUniforms[control.uniform] = parseFloat(e.target.value);
                        });
                        break;
                    case 'button': // TODO: this should be fixed to produce an impulse instead of a toggle
                        inputElement = document.createElement('button');
                        inputElement.textContent = control.label;
                        inputElement.addEventListener('click', () => {
                            customUniforms[control.uniform] = true;
                            console.log(`Action ${control.action} triggered for ${control.uniform}`);
                        });
                        break;
                    case 'toggle':
                        inputElement = document.createElement('input');
                        inputElement.type = 'checkbox';
                        inputElement.checked = control.default;
                        inputElement.addEventListener('change', (e) => {
                            customUniforms[control.uniform] = e.target.checked;
                        });
                        break;
                    case 'xy-plane':
                        inputElement = document.createElement('div');
                        inputElement.className = 'xy-plane';
                        const indicator = document.createElement('div');
                        indicator.className = 'xy-indicator';
                        indicator.style.left = (control.default.x * 200) + 'px';
                        indicator.style.top = (control.default.y * 200) + 'px';
                        inputElement.appendChild(indicator);
                        function updateXY(e) {
                            const rect = inputElement.getBoundingClientRect();
                            let rawX = e.clientX - rect.left;
                            let rawY = e.clientY - rect.top;
                            const clampedX = Math.min(Math.max(rawX, 0), rect.width);
                            const clampedY = Math.min(Math.max(rawY, 0), rect.height);
                            indicator.style.left = clampedX + 'px';
                            indicator.style.top = clampedY + 'px';
                            // Here we optionally use smoothstep to map the normalized value
                            customUniforms[control.uniform] = {
                                x: smoothstep(control.min.x || 0, control.max.x || 1, clampedX / rect.width),
                                y: smoothstep(control.min.y || 0, control.max.y || 1, 1 - clampedY / rect.height)
                            };
                        }
                        inputElement.addEventListener('mousedown', (e) => {
                            updateXY(e);
                            function onMouseMove(e) { updateXY(e); }
                            document.addEventListener('mousemove', onMouseMove);
                            document.addEventListener('mouseup', function onMouseUp() {
                                document.removeEventListener('mousemove', onMouseMove);
                                document.removeEventListener('mouseup', onMouseUp);
                            });
                        });
                        break;
                    case 'color-picker':
                        inputElement = document.createElement('input');
                        inputElement.type = 'color';
                        inputElement.value = control.default;
                        inputElement.addEventListener('input', (e) => {
                            customUniforms[control.uniform] = e.target.value;
                        });
                        break;
                    case 'dropdown':
                        inputElement = document.createElement('select');
                        control.options.forEach(option => {
                            const opt = document.createElement('option');
                            opt.value = option;
                            opt.textContent = option;
                            if (option === control.default) opt.selected = true;
                            inputElement.appendChild(opt);
                        });
                        inputElement.addEventListener('change', (e) => {
                            customUniforms[control.uniform] = e.target.value;
                        });
                        break;
                    case 'text-input':
                        inputElement = document.createElement('input');
                        inputElement.type = 'text';
                        inputElement.value = control.default;
                        inputElement.addEventListener('input', (e) => {
                            customUniforms[control.uniform] = e.target.value;
                        });
                        break;
                    default:
                        console.warn(`Unknown control type: ${control.type}`);
                }
                if (inputElement) {
                    controlDiv.appendChild(inputElement);
                }
                container.appendChild(controlDiv);
            });
        }

        // Render default controls on initial load
        document.addEventListener('DOMContentLoaded', () => {
            renderControls(defaultControlSchema);
        });
    </script>
</body>

</html>