#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="style.css">
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="blog.css">
#+HTML_HEAD: <style>img { max-width: 25vw; max-height: 25vw; }</style>

this is a work in progress

just some notes and demo shaders

* Waves

https://en.wikipedia.org/wiki/Waveform

** Sin
:PROPERTIES:
:ID:       a4337c68-8ceb-422f-947f-67f9511df925
:END:

#+NAME: sin
#+BEGIN_SRC glsl :file ./static/shadergen/sin.png :width 1000 :height 200 :exports both
  void main() {
      vec2 uv = (gl_FragCoord.xy - .5*iResolution.xy) / iResolution.xy;

      float th = uv.x;
      float phase = 0.;
      float amp = .25;
      float wavelength = (1./3.);
      float wav = amp * sin((th*3.14*2. - phase) / wavelength);
      fragColor = vec4(vec3(1.-smoothstep(.1, .11, abs(uv.y-wav))), 1.);
  }
#+END_SRC

Now we can do a fun trick to create a gradient

#+NAME: sin-gradient
#+BEGIN_SRC glsl :file ./static/shadergen/sin-gradient.png :width 1080 :height 566 :exports both
  #define PI 3.14159

  void main() {
      vec2 uv = (gl_FragCoord.xy - .5*iResolution.xy) / iResolution.xy;
      float th = uv.x;

      vec3 phase = (vec3(0.,1.,2.)/6.*PI - PI/3.)*3.;

      float amp = 1.;
      float wavelength = 1.;
      vec3 c = amp * sin((th*PI*2. - phase) / wavelength);
      fragColor = vec4(.5+.5*c, 1.);
  }
#+END_SRC

And even make some [[id:97fcb215-a181-4ccb-ac1f-3cadb942a9da][illusions]].

** Square

#+NAME: square
#+BEGIN_SRC glsl :file ./static/shadergen/square.png :width 1000 :height 200 :exports both
  void main() {
      vec2 uv = (gl_FragCoord.xy - .5*iResolution.xy) / iResolution.xy;

      // really this is just `sign(sin(x))`
      float wav = 0.25 * sign(sin((uv.x*3.14*2.)*3.));
      fragColor = vec4(vec3(1.-smoothstep(.1, .11, abs(uv.y-wav))), 1.);
  }
#+END_SRC

#+RESULTS: square
[[file:./static/shadergen/square.png]]

** Triangle

#+NAME: triangle
#+BEGIN_SRC glsl :file ./static/shadergen/triangle.png :width 1000 :height 200 :exports both
  #define PI 3.14159

  void main() {
      vec2 uv = (gl_FragCoord.xy - .5*iResolution.xy) / iResolution.xy;

      float th = uv.x;
      float phase = 0.;
      float amp = 0.25;
      float wavelength = 1./3.;

      float wav = ((2.*amp)/PI)* asin(sin((2.*PI*th - phase)/wavelength));
      fragColor = vec4(vec3(1.-smoothstep(.1, .11, abs(uv.y-wav))), 1.);
  }
#+END_SRC

#+RESULTS: triangle
[[file:./static/shadergen/triangle.png]]

** Sawtooth

#+NAME: sawtooth
#+BEGIN_SRC glsl :file ./static/shadergen/sawtooth.png :width 1000 :height 200 :exports both
  #define PI 3.14159

  void main() {
      vec2 uv = (gl_FragCoord.xy - .5*iResolution.xy) / iResolution.xy;

      float th = uv.x;
      float phase = 0.;
      float amp = 0.25;
      float wavelength = 1./3.;

      float wav = (2.*amp/PI) * atan(tan((th*2.*PI - phase) / (2.*wavelength)));
      fragColor = vec4(vec3(1.-smoothstep(.1, .11, abs(uv.y-wav))), 1.);
  }
#+END_SRC

#+RESULTS: sawtooth
[[file:./static/shadergen/sawtooth.png]]


* low-resolution patterns (like for light arrays)

* SDF

* Tips and Tricks

* Colors

** Color Spaces

*** hsv

Hue-- represented as an angle around a color wheel.  This implementation represents hue with a [0 .. 1] range instead of the normal [0 .. 2PI].

Saturation-- how white the color looks.

Value-- how black the color looks.

**** GLSL

Adaption of https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative

#+NAME: hsv-conversion-fns
#+BEGIN_SRC glsl :file /dev/null :exports code

  #ifndef HSV_CONVERSION_FNS
  #define HSV_CONVERSION_FNS

  #define PI 3.141592653589

  vec3 hsv2linear(vec3 hsv){
      vec3 k = mod(vec3(5.,3.,1.) + (hsv[0]*6.), 6.);
      return hsv[2] - hsv[2]*hsv[1]*clamp(min(k,4.-k),vec3(0.),vec3(1.));
  }

  vec3 linear2hsv(vec3 c) {
  #define R c.r
  #define G c.g
  #define B c.b
      float V = max(max(R,G),B);
      float VmC = min(min(R,G),B);
      // V-C = x
      // V-C-x = 0
      // V-x = C
      float C = V- VmC;
      // C = 2(V-L)
      // C = 2V - 2L
      // C + 2L = 2V
      // 2L = 2V - C
      float L = V - (C/2.);

      float H;
      float eps = 0.000001; // a small number
      if (abs(C) < eps) {
          H=0.;
      } else if (abs(V-R) < eps) {
          H = mod((G-B)/C, 6.);
      } else if (abs(V-G) < eps) {
          H = (B-R)/C + 2.;
      } else if (abs(V-B) < eps) {
          H = (R-G)/C + 4.;
      }
      H/=6.;

      float S = 0.;
      if (abs(V)>eps) S = C/V;

  #undef R
  #undef G
  #undef B

      return vec3(H,S,V);
  }

  #endif
#+END_SRC

If there are 3 colors we want to mix in 6 permutations:

| 1 | 0 | 0 |
| 1 | 1 | 0 |
| 0 | 1 | 0 |
| 0 | 1 | 1 |
| 0 | 0 | 1 |
| 1 | 0 | 1 |

then `hue` can be calculated by splitting the value into 6 sections, then choosing 2 colors for each section-- one to hold, and one to fade in/out

Saturation and Value represent how black/white the color looks.  These essentially move the max and min values for each color

This wikipedia example illustrates the idea quite intuitively:

https://upload.wikimedia.org/wikipedia/commons/5/5d/HSV-RGB-comparison.svg

**** Example

Given the above definitions we can manupulate colors thusly

#+NAME: hsv-colorspace-demo
#+BEGIN_SRC glsl :file ./static/shadergen/hsv-colorspace-demo.png :width 1080 :height 1080 :exports both :noweb no-export :noweb-prefix no
  // <<hsv-conversion-fns>>

  void main() {
      vec2 uv = gl_FragCoord.xy / iResolution.xy;
      vec2 uvz = (gl_FragCoord.xy - .5*iResolution.xy)/iResolution.y;

      float oh = sin(uv.x*PI*2.);
      float a = atan(uvz.y,uvz.x)-oh*.05*PI*2.;

      float y = uv.y+oh*.05;
      vec3 col = vec3(0.);
      // top color
      vec3 hsv1 = vec3(
          a/2./PI,                      // radial hue
          smoothstep(0.25,.5,y),  // fade in from white below
          1.-smoothstep(.5,1.1,y) // fade out to black above
          );
      // bottom color
      vec3 hsv2 = vec3(
          ((uv.x+oh*.1)*PI*2. + PI/2.)/2./PI, // hue shifts horizontally
          1.-smoothstep(-.1,.35,y),   // fade out to white above
          smoothstep(-.1,.2,y)        // fade in from black below
          );

      vec3 c1 = hsv2linear(hsv1);
      vec3 c2 = hsv2linear(hsv2);
      float sqsc = 6.;
      float wav = sin(y*2.*PI*sqsc+PI/2)*sin(uv.x*2.*PI*sqsc);

      // add a couple neat little effects
      float blur = 0.25;

  // shift hue a tad
  #define EFFECT1(C) C = mix(						\
          hsv2linear(linear2hsv(C)+vec3(-.05,0.,0.)),	\
          C,										\
          smoothstep(-blur,blur,wav));
  // desaturate slightly
  #define EFFECT2(C) C = mix(						\
          hsv2linear(linear2hsv(C)*vec3(1.,.7,.8)),		\
          C,										\
          smoothstep(-blur,blur,wav));

      EFFECT1(c1);
      EFFECT2(c2);

      col = mix(c2,c1,smoothstep(.2,.25,y));

      fragColor = vec4(col,1.0);
  }
#+END_SRC

*** hsl

TODO: this

*** srgb

Gamma-corrected RGB, with brightness mapped onto a non-linear curve.

All values remain within the [0..1] range.

**** GLSL

Based on https://en.wikipedia.org/wiki/SRGB#Transfer_function_(%22gamma%22)

#+NAME: srgb-conversion-fns
#+BEGIN_SRC glsl :file /dev/null :exports code

  #ifndef RGB_CONVERSION_FNS
  #define RGB_CONVERSION_FNS

  // ---------- sRGB <-> linear RGB ("RGB") -------------------------------------
  // from https://en.wikipedia.org/wiki/SRGB#Transfer_function_(%22gamma%22)

  float srgb2linear(float c)  {
      return (c <= 0.04045) ? (c/12.92) : pow((c+0.055)/1.055, 2.4);
  }
  vec3  srgb2linear(vec3  c)  {
      return vec3(srgb2linear(c.r), srgb2linear(c.g), srgb2linear(c.b));
  }
  float linear2srgb(float c)  {
      // inverse of above
      return (c <= 0.0031308) ? (12.92*c) : (1.055*pow(c, 1.0/2.4) - 0.055);
  }
  vec3  linear2srgb(vec3  c)  {
      return vec3(linear2srgb(c.r), linear2srgb(c.g), linear2srgb(c.b));
  }

  #endif
#+END_SRC

**** Example

#+NAME: srgb-colorspace-demo
#+BEGIN_SRC glsl :file ./static/shadergen/srgb-colorspace-demo.png :width 1080 :height 1080 :exports both :noweb no-export :noweb-prefix no
  // <<srgb-conversion-fns>>
  // <<hsv-conversion-fns>>
  // <<oklch-conversion-fns>>

  void main() {
      vec2 uv = gl_FragCoord.xy / iResolution.xy;
      vec2 uvz = (gl_FragCoord.xy - .5*iResolution.xy)/iResolution.y;

      vec3 top = hsv2linear(vec3(uv.x,1.,1.));
      vec3 bottom = linear2srgb(top);
      vec3 col = mix(bottom,top,step(0.,uvz.y));

      // treat SRGB as linear to compare perceptual lightness
      float lightness = linear2oklch(col)[0];
      if (abs(uvz.y)<0.25) col = vec3(lightness);

      fragColor = vec4(col,1.0);
  }
#+END_SRC

Comparing linear RGB (top) to the gamma-corrected sRGB (bottom) gradient we can observe a more visually consistent lightness

*** oklab

Please read https://bottosson.github.io/posts/oklab/#converting-from-linear-srgb-to-oklab for a thorough explanation of how this all works.

Lightness is in range [0 .. 1]

`A` represents the green/red axis in a [-0.37 .. 0.37] range.

`B` represents the blue/yellow axis in a [-0.37 .. 0.37] range.

**** GLSL

Note that Lightness has a value range of [0..1] and A,B have range [-0.37 .. 0.37]

#+NAME: oklab-conversion-fns
#+BEGIN_SRC glsl :file /dev/null :exports code :noweb no-export :noweb-prefix no

  #ifndef OKLAB_CONVERSION_FNS
  #define OKLAB_CONVERSION_FNS

  // <<srgb-conversion-fns>>

  // --- linear RGB <-> OKLab (Björn Ottosson reference implementation) ---

  vec3 linear2oklab(vec3 c) {
      // linear sRGB -> LMS
      float l = 0.4122214708*c.r + 0.5363325363*c.g + 0.0514459929*c.b;
      float m = 0.2119034982*c.r + 0.6806995451*c.g + 0.1073969566*c.b;
      float s = 0.0883024619*c.r + 0.2817188376*c.g + 0.6299787005*c.b;

      // nonlinearity
      float l_ = pow(l, 1./3.);
      float m_ = pow(m, 1./3.);
      float s_ = pow(s, 1./3.);

      // LMS -> OKLab
      return vec3(
          0.2104542553*l_ + 0.7936177850*m_ - 0.0040720468*s_,
          1.9779984951*l_ - 2.4285922050*m_ + 0.4505937099*s_,
          0.0259040371*l_ + 0.7827717662*m_ - 0.8086757660*s_
          );
  }

  vec3 oklab2linear(vec3 c) {
      // OKLab -> intermediate LMS'
      float l_ = c.x + 0.3963377774*c.y + 0.2158037573*c.z;
      float m_ = c.x - 0.1055613458*c.y - 0.0638541728*c.z;
      float s_ = c.x - 0.0894841775*c.y - 1.2914855480*c.z;

      // undo nonlinearity
      float l = l_*l_*l_;
      float m = m_*m_*m_;
      float s = s_*s_*s_;

      // LMS -> linear sRGB
      return vec3(
          +4.0767416621*l - 3.3077115913*m + 0.2309699292*s,
          -1.2684380046*l + 2.6097574011*m - 0.3413193965*s,
          -0.0041960863*l - 0.7034186147*m + 1.7076147010*s
          );
  }

  // --- sRGB (display) <-> OKLab convenience wrappers ---

  vec3 srgb2oklab(vec3 srgb) {
      return linear2oklab( srgb2linear(srgb) ); // gamma → linear → OKLab
  }

  vec3 oklab2srgb(vec3 lab) {
      return linear2srgb( oklab2linear(lab) ); // OKLab → linear → gamma
  }

  #endif
#+END_SRC

**** Example

Given the above devinitions we can do some lightness equalization on a gradient.

#+NAME: oklab-demo
#+BEGIN_SRC glsl :file ./static/shadergen/oklab-colorspace-demo.png :width 1080 :height 1080 :exports both :noweb no-export :noweb-prefix no

  // <<oklab-conversion-fns>>

  #define PI 3.14159

  void main() {
      vec2 uv = (gl_FragCoord.xy - .5*iResolution.xy) / iResolution.xy;
      float th = uv.x;

      vec3 phase = (vec3(0.,1.,2.)/6.*PI - PI/3.)*3.;

      float amp = 1.;
      float wavelength = 1.;
      vec3 c = amp * sin((th*PI*2.*2. - phase) / wavelength);
      c = .5+.5*c;

      if (uv.y < 0.) {
          vec3 lab = linear2oklab(c);
          c = oklab2linear(vec3(
                               // constant lightness
                               0.85,
                               // increasing magnitude of `a,b` increases chroma
                               // to account for changing lightness
                               1.5*lab[1],
                               1.5*lab[2]));
      }
      // compare lightness between rgb and lab gradients
      if (abs(uv.y)<0.25) {
          // yea we can go right ahead and reuse our OKLAB function
          // to calculate lightness
          float lightness = linear2oklab(c)[0];
          c.rgb = vec3(lightness);
      }
      fragColor = vec4(c, 1.);
  }
#+END_SRC

*** oklch

Lightness in range [0 .. 1]

Chroma represents colorfulness (similar, but not the same as, saturation-- see [[https:https://en.wikipedia.org/wiki/Colorfulness][wikipedia Colorfulness]] article for detauls).  It spans the range of [0 .. 0.37]

Hue is an angle around a color wheel, with a [0 .. 2PI] range.


Chroma and Hue can be calculated directly from OKLAB:

#+BEGIN_SRC
C(l a b) = sqrt(a^2 + b^2)

H(l a b) = atan2(b,a)
#+END_SRC

**** GLSL

#+NAME: oklch-conversion-fns
#+BEGIN_SRC glsl :file /dev/null :exports code :noweb no-export :noweb-prefix no

  #ifndef OKLCH_CONVERSION_FNS
  #define OKLCH_CONVERSION_FNS

  // <<oklab-conversion-fns>>

  vec3 oklab2oklch(vec3 lab){
      float C = length(lab.yz);
      float h = atan(lab.z, lab.y); if(h < 0.0) h += 2.0*3.14159;
      return vec3(lab.x, C, h);
  }
  vec3 oklch2oklab(vec3 lch){
      return vec3(lch.x, lch.y*cos(lch.z), lch.y*sin(lch.z));
  }
  vec3 oklch2linear(vec3 oklch) {
      return oklab2linear(oklch2oklab(oklch));
  }
  vec3 linear2oklch(vec3 linear) {
      return oklab2oklch(linear2oklab(linear));
  }

  #endif
#+END_SRC

**** Example

#+NAME: oklch-demo
#+BEGIN_SRC glsl :file ./static/shadergen/oklch-colorspace-demo.png :width 1080 :height 1080 :exports both :noweb no-export :noweb-prefix no

  // <<oklch-conversion-fns>>

  #define PI 3.14159

  void main() {
      vec2 uv = (gl_FragCoord.xy - .5*iResolution.xy) / iResolution.xy;

      vec3 c = oklch2linear(vec3(
                                // Lightness range [0 .. 1]
                                1.-length(uv),
                                // Chroma range [0 .. 0.37]
                                mix(0., 0.37, length(uv)),
                                // Hue range [0 .. 2PI] and wraps back around
                                atan(uv.y,uv.x)*4.
                                ));
      fragColor = vec4(c, 1.);
  }
#+END_SRC

** demos

*** Compare Color Spaces

Idea yoinked from this xorDev post https://twitter.com/XorDev/status/1730330783892574668

#+NAME: color-mix
#+BEGIN_SRC glsl :file ./static/shadergen/color-mix-shader-out.png :width (* 3. 1080) :height 1080 :exports both :noweb no-export :noweb-prefix no
  // <<hsv-conversion-fns>>
  // <<srgb-conversion-fns>>
  // <<oklab-conversion-fns>>
  // <<oklch-conversion-fns>>

  #ifndef MODE
  # define MODE 0
  #endif

  void main() {
      vec2 uv = gl_FragCoord.xy / iResolution.xy;
      vec2 uvz = (gl_FragCoord.xy - .5*iResolution.xy)/iResolution.y;

      float a = atan(uvz.y,uvz.x);

      vec3 ca = vec3(1.,1.,0.);
      vec3 cb = vec3(0.,0.,1.);

      float nbands = 5.;
      int band = int(nbands-ceil(uv.y*nbands));
  #define CONV(V,F) V = F(V)
      switch (band) {
      case 0: // linear
          break;
      case 1: // srgb (gamma corrected)
          CONV(ca, linear2srgb);
          CONV(cb, linear2srgb);
          break;
      case 2: // oklab
          CONV(ca, linear2oklab);
          CONV(cb, linear2oklab);
          break;
      case 3: // oklch
          CONV(ca, linear2oklch);
          CONV(cb, linear2oklch);
          break;
      case 4: // hsv
          CONV(ca, linear2hsv);
          CONV(cb, linear2hsv);
          break;
      }

      float n = 10.;
      float id = floor(fract(uv.x*2.)*n);
      vec3 col = mix(ca,cb, id/(n-1.));

      vec3 col2 = mix(ca,cb, (id+1)/(n-1));

      // top to bottom
      switch (band) {
      case 0: // linear
          break;
      case 1: // srgb (gamma corrected)
          CONV(col, srgb2linear);
          CONV(col2, srgb2linear);
          break;
      case 2: // oklab
          CONV(col, oklab2linear);
          CONV(col2, oklab2linear);
          break;
      case 3: // oklch
          CONV(col, oklch2linear);
          CONV(col2, oklch2linear);
          break;
      case 4: // hsv
          CONV(col, hsv2linear);
          CONV(col2, hsv2linear);
          break;
      }

  #if MODE==0
      if (uv.x>.5)
          col = linear2oklch(col).rrr;
  #else
      if (uv.x>.5)
          col = abs(linear2oklch(col).rrr-linear2oklch(col2).rrr);
      else
          col = vec3(0.)+(col-col2);
  #endif

      fragColor = vec4(col,1.0);
  }
#+END_SRC

Here we see (top-down):

Linear RGB does an acceptable job.

sRGB looks ridiculous.

OKLAB (middle) looks pretty ok.

OKLCH introduces an unexpected green-- this is because it interpolates the hue from yellow to blue through green.

HSV produces by far the worst results in terms of perception-accurate color interpolation.

We can even visualize the change between cells.  On the left is change in RGB values, and on the right we can see change in lightness.

#+NAME: color-mix-skibidi
#+BEGIN_SRC glsl :file ./static/shadergen/color-mix-shader-out-skibidi.png :width (* 3. 1080) :height 1080 :exports results :noweb no-export :noweb-prefix no
  #define MODE 1
  // <<color-mix>>
#+END_SRC

*** lch hsv comparison

#+NAME: color-mix-cmp-1
#+BEGIN_SRC glsl :file ./static/shadergen/color-mix-shader-out-whaa.png :width 1080 :height 1080 :exports both :noweb no-export :noweb-prefix no
  // <<hsv-conversion-fns>>
  // <<srgb-conversion-fns>>
  // <<oklab-conversion-fns>>
  // <<oklch-conversion-fns>>

  void main() {
      vec2 uv = gl_FragCoord.xy / iResolution.xy;
      vec2 uvz = (gl_FragCoord.xy - .5*iResolution.xy)/iResolution.y;

      vec3 col = vec3(1.,1.,1.);

      float a = atan(uvz.y,uvz.x);
      float wav = sin(a*6+sin(length(uvz)*PI*6.*2.)*PI+length(uvz)*PI*2.*6.);

      vec3 lch = vec3(1., length(uvz), atan(uvz.y,uvz.x)+wav);
      vec3 ca = oklch2linear(lch);
      vec3 cb = hsv2linear(vec3(lch[2]/2./PI+0.25, lch[1], lch[0]));

      float blur = fwidth(wav+.5);
      // This should highlight different properties of the
      // LCH `chroma` value and
      // HSV `saturation` value
      col = mix(ca,cb,smoothstep(-blur,blur,wav));

      fragColor = vec4(col,1.0);
  }
#+END_SRC

#+RESULTS: color-mix-cmp-1
[[file:./static/shadergen/color-mix-shader-out-whaa.png]]

** All the functions for your copy-pasting pleasure

#+NAME: colorspace-megadump
#+BEGIN_SRC glsl :file /dev/null :exports code :noweb yes :noweb-prefix no
  // <<hsv-conversion-fns>>
  // <<srgb-conversion-fns>>
  // <<oklab-conversion-fns>>
  // <<oklch-conversion-fns>>
#+END_SRC

* Illusions

** Peripheral Drift

Rapid blinking usually intensifies the effect

https://en.wikipedia.org/wiki/Peripheral_drift_illusion

*** Radial example

#+NAME: peripheral drift
#+BEGIN_SRC glsl :file ./static/shadergen/peripheral-drift.png :width 1000 :height 1000 :exports both

  #define PI 3.141592653589

  mat2 rot(float t) { return mat2(cos(t),-sin(t),sin(t),cos(t)); }

  void main() {
      vec2 uv = gl_FragCoord.xy / iResolution.xy;
      vec2 uvz = (gl_FragCoord.xy - .5*iResolution.xy)/iResolution.y;

      float sc = 30.;
      vec2 pth = uvz*vec2(1.,.8)*sc;
      vec2 p = fract(pth)-.5;
      float blur = sc/iResolution.y;

      vec3 col = vec3(0.);
      float d = length(abs(p));
      float d1 = 1.- smoothstep(.3,.3+blur,d);
      float d2 = 1.-smoothstep(.4,.4+blur,d);
      vec3 outlineCol = mix(vec3(0.),vec3(1.), d2);
      if ((rot(atan(uvz.x,uvz.y)*8.+cos(uv.x)+sin(uv.y))*p).y<0.) outlineCol *= .0;
      col = mix(outlineCol, vec3(0.9,.8,.9), d1);
      col = mix(vec3(.5), col, d2);

      fragColor = vec4(col,1.0);
  }
#+END_SRC

#+RESULTS: peripheral drift
[[file:./static/shadergen/peripheral-drift.png]]

*** Contrasting colors strengthen the effect

Cololrs based on wikipedia [[https://en.wikipedia.org/wiki/Peripheral_drift_illusion#/media/File:Anomalous_motion_illusion1.svg][example]] by Paul Nasca

#+NAME: peripheral drift 2
#+BEGIN_SRC glsl :file ./static/shadergen/peripheral-drift-2.png :width 1000 :height 1000 :exports both
  #define PI (355./113.)

  void main()
  {
      vec2 uvz = (gl_FragCoord.xy - .5*iResolution.xy)/iResolution.y;

      float w = mix(
          sin(abs(uvz.y)*5.*PI+abs(uvz.x)*5.*PI -PI/2.),
          sin(atan(uvz.x,uvz.y)*4.+length(uvz)*8.+sin(length(uvz)*10.)*2.*2.),
          smoothstep(0.,0.1,-uvz.y)
          );
      vec2 p = abs(uvz+w*.01);

      float sc = 20.;
      float blur = sc/iResolution.y;
  #if 0
      float d1 = step(.4, length(fract(uvz*sc)-.5));
      float d2 = step(.4, length(fract( p *sc)-.5));
  #else
      float d1 = smoothstep(.4-blur,.4+blur, length(fract(uvz*sc)-.5));
      float d2 = smoothstep(.4-blur,.4+blur, length(fract( p *sc)-.5));
  #endif


      vec3 green = vec3(0.0,1.0,0.0);
      vec3 white = vec3(1.0);
      vec3 black = vec3(0.0);
      vec3 blue  = vec3(0.0,0.0,1.0);

      vec3 col = mix(
          mix(green, white, d1),
          mix(black,  blue,  d1),
          d2
          );

      fragColor = vec4(col,1.0);
  }
#+END_SRC

#+RESULTS: peripheral drift 2
[[file:./static/shadergen/peripheral-drift-2.png]]

*** Throbert

Lots of album covers use this kind of throbbing effect

#+NAME: peripheral drift 3
#+BEGIN_SRC glsl :file ./static/shadergen/peripheral-drift-3.png :width 1000 :height 1000 :exports both
  #define PI (355./113.)

  void main()
  {
      vec2 uv = (gl_FragCoord.xy - .5*iResolution.xy)/iResolution.y;

      float a = atan(uv.x,uv.y);
      vec3 col = cos(
          vec3(0.,.75,1.5)
          +(sin(a*8.)*PI+length(uv)*PI*16.*1.)
          * sin(a*8.+PI/2.)
          )*.5+.5;

      fragColor = vec4(col,1.0);
  }
#+END_SRC

#+RESULTS: peripheral drift 3
[[file:./static/shadergen/peripheral-drift-3.png]]

*** Gradient
:PROPERTIES:
:ID:       97fcb215-a181-4ccb-ac1f-3cadb942a9da
:END:

Or we could get artsy with it using our [[id:a4337c68-8ceb-422f-947f-67f9511df925][sin gradient]] trick

#+NAME: pdrift-sin-1
#+BEGIN_SRC glsl :file ./static/shadergen/pdrift-sin-1.png :width 1080 :height 566 :exports both
  void main() {
      vec2 uv = (gl_FragCoord.xy - vec2(.5,.55)*iResolution.xy) / iResolution.xy;
      float th = abs(uv.x)*2.;
      vec3 phase = (vec3(0.,1.,2.)/6.*3.14+abs(uv.x)*3.14*10.-3.14/3.)*3.;

      float bend = mix( 1.,.25 ,abs(uv.x)*2.); // offset to amplitude
      float amp = cos(uv.y*3.14*20.*bend);

      float wavelength = 1.;
      vec3 c = amp * sin((th*3.14*2. - phase) / wavelength);
      fragColor = vec4(.5+.5*c, 1.);
  }
#+END_SRC

#+NAME: pdrift-sin-2
#+BEGIN_SRC glsl :file ./static/shadergen/pdrift-sin-2.png :width 1080 :height 566 :exports both
  void main() {
      vec2 r = vec2(.5,.525);
      vec2 uv = (gl_FragCoord.xy - r*iResolution.xy) / iResolution.xy;
      if (uv.y<0.) uv.y *= r.x/r.y;
      else uv.y /= r.x/r.y;
      float nCells = 10.;

      float th = abs(uv.y)*2.;
      vec3 phase = (
          vec3(0.,1.,2.)/6.*3.14*abs(uv.y)*2.*mix(.8,1.2,abs(uv.x)*2.)
          +abs(uv.y)*3.14*nCells
          +3.1415926/3.*.5
          )*3.;

      float pw = 1.-pow(1.-abs(uv.y*2.),2.);
      float amp = cos(
          uv.x*3.14*2.*10.
          /mix(0.334,1.,abs(uv.y)) // perspective
          )*(.5+.5*pw)// distance fog
          ;

      float wavelength = 1.;
      vec3 c = amp * sin((th*3.14*2. - phase) / wavelength);
      fragColor = vec4(.5+.5*c, 1.);
  }
#+END_SRC

#+NAME: pdrift-sin-3
#+BEGIN_SRC glsl :file ./static/shadergen/pdrift-sin-3.png :width 1080 :height 566 :exports both
  void main() {
      vec2 uv = (gl_FragCoord.xy - vec2(.5,.55)*iResolution.xy) / iResolution.xy;
      float th = abs(uv.x)*2.;

      vec3 phase = (-vec3(0.,1.,2.)/6.*3.14+abs(uv.x)*3.14*10.-3.14/3.)*3.;
      float bend = mix( 1.,.25 ,abs(uv.y)*2.); // offset to amplitude
      float amp = cos(abs(uv.x)*3.14*20.*bend + 3.14);

      float wavelength = 1.;
      vec3 c = amp * sin((th*3.14*2. - phase) / wavelength);
      fragColor = vec4(.5+.5*c, 1.);
  }
#+END_SRC
