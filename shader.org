#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="style.css">
#+HTML_HEAD: <style>img { max-width: 25vw; max-height: 25vw; }</style>

this is a work in progress

just some notes and demo shaders

* Waves

https://en.wikipedia.org/wiki/Waveform

** Sin

#+NAME: sin
#+BEGIN_SRC glsl :file ./static/sin.png :width 1000 :height 200 :exports both
  void main() {
      vec2 uv = (gl_FragCoord.xy - .5*iResolution.xy) / iResolution.xy;

      float th = uv.x;
      float phase = 0.;
      float amp = .25;
      float wavelength = (1./3.);
      float wav = amp * sin((th*3.14*2. - phase) / wavelength);
      fragColor = vec4(vec3(1.-smoothstep(.1, .11, abs(uv.y-wav))), 1.);
  }
#+END_SRC

#+RESULTS: sin
[[file:./static/sin.png]]

** Square

#+NAME: square
#+BEGIN_SRC glsl :file ./static/square.png :width 1000 :height 200 :exports both
  void main() {
      vec2 uv = (gl_FragCoord.xy - .5*iResolution.xy) / iResolution.xy;

      float wav = sign(sin(uv.x*3.14*2. * 3.))*.25;
      fragColor = vec4(vec3(1.-smoothstep(.1, .11, abs(uv.y-wav))), 1.);
  }
#+END_SRC

#+RESULTS: square
[[file:./static/square.png]]

** Triangle

#+NAME: triangle
#+BEGIN_SRC glsl :file ./static/triangle.png :width 1000 :height 200 :exports both
  void main() {
      vec2 uv = (gl_FragCoord.xy - .5*iResolution.xy) / iResolution.xy;

      float wav = asin(sin(uv.x*2.*3.14 * 3.)) * (2.*.25/3.14);
      fragColor = vec4(vec3(1.-smoothstep(.1, .11, abs(uv.y-wav))), 1.);
  }
#+END_SRC

#+RESULTS: triangle
[[file:./static/triangle.png]]

** Sawtooth

#+NAME: sawtooth
#+BEGIN_SRC glsl :file ./static/sawtooth.png :width 1000 :height 200 :exports both
  void main() {
      vec2 uv = (gl_FragCoord.xy - .5*iResolution.xy) / iResolution.xy;

      float wavelength = 1.;
      float wav = atan(tan((uv.x*2.*3.14 * 3.) / (2.*wavelength))) * (2.*.25/3.14);
      fragColor = vec4(vec3(1.-smoothstep(.1, .11, abs(uv.y-wav))), 1.);
  }
#+END_SRC

#+RESULTS: sawtooth
[[file:./static/sawtooth.png]]


* low-resolution patterns (like for light arrays)

* SDF

* Tips and Tricks

* Colors

TODO: invert, mix

conversions
HSV/RGB
** conversions

see xorDev post https://twitter.com/XorDev/status/1730330783892574668

*** hsv

Adaption of https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative

#+NAME: hsv-to-rgb
#+BEGIN_SRC glsl :file ./static/hsv-to-rgb.png :width 1080 :height 1080 :exports both

  #define PI 3.141592653589

  vec3 hsv2rgb(vec3 hsv){
      // presumptuous degree commented out in favor the modest radian
      // vec3 k = mod(vec3(5.,3.,1.) + (hsv[0]/60.), 6.);
      vec3 k = mod(vec3(5.,3.,1.) + (hsv[0]*3./PI), 6.);
      return hsv[2] - hsv[2]*hsv[1]*clamp(min(k,4.-k),vec3(0.),vec3(1.));
  }

  vec3 rgb2hsv(vec3 c) {
  #define R c.r
  #define G c.g
  #define B c.b
      float V = max(max(R,G),B);
      float VmC = min(min(R,G),B);
      // V-C = x
      // V-C-x = 0
      // V-x = C
      float C = V- VmC;
      // C = 2(V-L)
      // C = 2V - 2L
      // C + 2L = 2V
      // 2L = 2V - C
      float L = V - (C/2.);

      float H;
      float eps = 0.000001; // a small number
      if (abs(C) < eps) {
          H=0.;
      } else if (abs(V-R) < eps) {
          H = mod((G-B)/C, 6.);
      } else if (abs(V-G) < eps) {
          H = (B-R)/C + 2.;
      } else if (abs(V-B) < eps) {
          H = (R-G)/C + 4.;
      }
      H *= PI/3.;

      float S = 0.;
      if (abs(V)>eps) S = C/V;

  #undef R
  #undef G
  #undef B

      return vec3(H,S,V);
  }

  void main() {
      vec2 uv = gl_FragCoord.xy / iResolution.xy;
      vec2 uvz = (gl_FragCoord.xy - .5*iResolution.xy)/iResolution.y;

      float oh = sin(uv.x*PI*2.);
      float a = atan(uvz.y,uvz.x)-oh*.05*PI*2.;

      float y = uv.y+oh*.05;
      vec3 col = vec3(0.);
      // top color
      vec3 hsv1 = vec3(
          a,                      // radial hue
          smoothstep(0.25,.5,y),  // fade in from white below
          1.-smoothstep(.5,1.1,y) // fade out to black above
          );
      // bottom color
      vec3 hsv2 = vec3(
          (uv.x+oh*.1)*PI*2. + PI/2., // hue shifts horizontally
          1.-smoothstep(-.1,.35,y),   // fade out to white above
          smoothstep(-.1,.2,y)        // fade in from black below
          );
      vec3 c1 = hsv2rgb(hsv1);
      vec3 c2 = hsv2rgb(hsv2);
      float sqsc = 6.;
      float wav = sin(y*2.*PI*sqsc+PI/2)*sin(uv.x*2.*PI*sqsc);
      float wav2 = sin(y*2.*PI*sqsc*3.+PI/2)*sin(uv.x*2.*PI*sqsc*3.);
      // add a couple neat little effects
      float blur = 0.25;
      // TODO: swap top/bottom effects

      //                                            decrease saturation and shift hue
  #define EFFECT1(C) C = mix(C*hsv2rgb(rgb2hsv(C)*vec3(1.,.95,1.)+vec3(PI,0.,0.)), C, smoothstep(-blur,blur,wav2));
      //                                            shift hue a tad
  #define EFFECT2(C) C = mix(hsv2rgb(rgb2hsv(C)+vec3(-PI/3.,0.,0.)), C, smoothstep(-blur,blur,wav));
      //        c1 = mix(c1*hsv2rgb(rgb2hsv(c1)*vec3(1.,.95,1.)+vec3(PI,0.,0.)), c1, smoothstep(-blur,blur,wav));
      EFFECT1(c2);
      EFFECT2(c1);

      col = mix(c2,c1,smoothstep(.2,.25,y));

      // Output to screen
      fragColor = vec4(col,1.0);
  }
#+END_SRC

*** hsl
*** sRGB (gamma-corrected)
*** OKLCH (this one bangs)

TODO: fix this one (it is wrong)

#+NAME: color-mix
#+BEGIN_SRC glsl :file ./static/color-mix-shader-out.png :width 1080 :height 1080 :exports both

  #define PI 3.14159

  vec3 hsv2rgb(vec3 hsv){
      // presumptuous degree commented out in favor the modest radian
      // vec3 k = mod(vec3(5.,3.,1.) + (hsv[0]/60.), 6.);
      vec3 k = mod(vec3(5.,3.,1.) + (hsv[0]*3./PI), 6.);
      return hsv[2] - hsv[2]*hsv[1]*clamp(min(k,4.-k),vec3(0.),vec3(1.));
  }

  vec3 rgb2hsv(vec3 c) {
  #define R c.r
  #define G c.g
  #define B c.b
      float V = max(max(R,G),B);
      float VmC = min(min(R,G),B);
      // V-C = x
      // V-C-x = 0
      // V-x = C
      float C = V- VmC;
      // C = 2(V-L)
      // C = 2V - 2L
      // C + 2L = 2V
      // 2L = 2V - C
      float L = V - (C/2.);

      float H;
      float eps = 0.000001; // a small number
      if (abs(C) < eps) {
          H=0.;
      } else if (abs(V-R) < eps) {
          H = mod((G-B)/C, 6.);
      } else if (abs(V-G) < eps) {
          H = (B-R)/C + 2.;
      } else if (abs(V-B) < eps) {
          H = (R-G)/C + 4.;
      }
      H *= PI/3.;

      float S = 0.;
      if (abs(V)>eps) S = C/V;

  #undef R
  #undef G
  #undef B

      return vec3(H,S,V);
  }

  // ---------- sRGB <-> linear RGB ("RGB") -------------------------------------
  float srgb_to_rgb(float c)  { return (c <= 0.04045) ? (c/12.92) : pow((c+0.055)/1.055, 2.4); }
  vec3  srgb_to_rgb(vec3  c)  { return vec3(srgb_to_rgb(c.r), srgb_to_rgb(c.g), srgb_to_rgb(c.b)); }

  float rgb_to_srgb(float c)  { return (c <= 0.0031308) ? (12.92*c) : (1.055*pow(c, 1.0/2.4) - 0.055); }
  vec3  rgb_to_srgb(vec3  c)  { return clamp(vec3(rgb_to_srgb(c.r), rgb_to_srgb(c.g), rgb_to_srgb(c.b)), 0.0, 1.0); }

  // ---------- small helpers ---------------------------------------------------
  vec3 cbrt(vec3 v){ return vec3(pow(v.x, 1.0/3.0), pow(v.y, 1.0/3.0), pow(v.z, 1.0/3.0)); }
  vec3 cube(vec3 v){ return v*v*v; }

  // ---------- OKLab/OKLCH core matrices (COLUMN-MAJOR!) -----------------------
  // linear RGB -> LMS
  const mat3 M1 = mat3(
      0.4122214708, 0.2119034982, 0.0883024619,   // column for R
      0.5363325363, 0.6806995451, 0.2817188376,   // column for G
      0.0514459929, 0.1073969566, 0.6299787005    // column for B
      );
  // LMS^(1/3) -> OKLab
  const mat3 M2 = mat3(
      0.2104542553,  1.9779984951,  0.0259040371, // column for l'
      0.7936177850, -2.4285922050,  0.7827717662, // column for m'
      -0.0040720468,  0.4505937099, -0.8086757660  // column for s'
      );

  // Inverses: OKLab -> LMS^(1/3) and LMS -> linear RGB
  const mat3 M2_INV = mat3(
      1.0000000000,  1.0000000000,  1.0000000000,  // column for L
      0.3963377774, -0.1055613458, -0.0894841775,  // column for a
      0.2158037573, -0.0638541728, -1.2914855480   // column for b
      );
  const mat3 M1_INV = mat3(
      4.0767416621, -1.2684380046, -0.0041960863, // column for l
      -3.3077115913,  2.6097574011, -0.7034186147, // column for m
      0.2309699292, -0.3413193965,  1.7076147010  // column for s
      );

  // ---------- linear RGB ("RGB") <-> OKLCH ------------------------------------
  vec3 rgb_to_oklch(vec3 rgb) {
      vec3 lms  = M1 * rgb;
      vec3 lms_ = cbrt(lms);
      vec3 lab  = M2 * lms_;

      float L = lab.x;
      float a = lab.y;
      float b = lab.z;

      float C = length(vec2(a,b));
      float h = (C > 0.0) ? atan(b, a) : 0.0;       // radians

      // if you prefer [0, 2Ï€): if (h < 0.0) h += 6.283185307179586;
      return vec3(L, C, h);
  }

  vec3 oklch_to_rgb(vec3 LCh) {
      float L = LCh.x, C = LCh.y, h = LCh.z;
      float a = C * cos(h);
      float b = C * sin(h);

      vec3 lms_ = M2_INV * vec3(L, a, b);          // l', m', s'
      vec3 lms  = cube(lms_);
      return M1_INV * lms;                          // linear RGB
  }

  // ---------- sRGB <-> OKLCH convenience wrappers -----------------------------
  vec3 srgb_to_oklch(vec3 srgb) { return rgb_to_oklch(srgb_to_rgb(srgb)); }
  vec3 oklch_to_srgb(vec3 LCh)  { return rgb_to_srgb(oklch_to_rgb(LCh)); }

  void main() {
      vec2 uv = gl_FragCoord.xy / iResolution.xy;
      vec2 uvz = (gl_FragCoord.xy - .5*iResolution.xy)/iResolution.y;

      vec3 col = vec3(1.,1.,1.);

      float a = atan(uvz.y,uvz.x);

      //	vec3 hsv = vec3(a,1.,1.);

      vec3 ca = vec3(1.,1.,0.);
      vec3 cb = vec3(0.,0.,1.);
      bool below = uvz.y<0.;
      if (below) {
          // ca = oklch_to_rgb(rgb_to_oklch(ca));
          // cb = oklch_to_rgb(rgb_to_oklch(cb));
          ca = rgb_to_oklch(ca);
          cb = rgb_to_oklch(cb);
      }

      col = mix(ca,cb, uv.x);
      if (below) col = oklch_to_rgb(col);

      //      if (uvz.y<0.) col = 1.-((1.-ca*(1.-uv.x))*(1.-cb*uv.x));
      //      if (uvz.y<0.) col = rgb_to_oklch(mix(oklch_to_rgb(ca), oklch_to_rgb(cb), uv.x));
      fragColor = vec4(col,1.0);
  }
#+END_SRC


* Illusions

** Peripheral Drift

Rapid blinking usually intensifies the effect

https://en.wikipedia.org/wiki/Peripheral_drift_illusion

*** Radial example

#+NAME: peripheral drift
#+BEGIN_SRC glsl :file ./static/peripheral-drift.png :width 1000 :height 1000 :exports both

  #define PI 3.141592653589

  mat2 rot(float t) { return mat2(cos(t),-sin(t),sin(t),cos(t)); }

  void main() {
      vec2 uv = gl_FragCoord.xy / iResolution.xy;
      vec2 uvz = (gl_FragCoord.xy - .5*iResolution.xy)/iResolution.y;

      float sc = 30.;
      vec2 pth = uvz*vec2(1.,.8)*sc;
      vec2 p = fract(pth)-.5;
      float blur = sc/iResolution.y;

      vec3 col = vec3(0.);
      float d = length(abs(p));
      float d1 = 1.- smoothstep(.3,.3+blur,d);
      float d2 = 1.-smoothstep(.4,.4+blur,d);
      vec3 outlineCol = mix(vec3(0.),vec3(1.), d2);
      if ((rot(atan(uvz.x,uvz.y)*8.+cos(uv.x)+sin(uv.y))*p).y<0.) outlineCol *= .0;
      col = mix(outlineCol, vec3(0.9,.8,.9), d1);
      col = mix(vec3(.5), col, d2);

      // Output to screen
      fragColor = vec4(col,1.0);
  }
#+END_SRC

#+RESULTS: peripheral drift
[[file:./static/peripheral-drift.png]]

*** Contrasting colors strengthen the effect

Cololrs based on wikipedia [[https://en.wikipedia.org/wiki/Peripheral_drift_illusion#/media/File:Anomalous_motion_illusion1.svg][example]] by Paul Nasca

#+NAME: peripheral drift 2
#+BEGIN_SRC glsl :file ./static/peripheral-drift-2.png :width 1000 :height 1000 :exports both
  #define PI (355./113.)

  void main()
  {
      vec2 uvz = (gl_FragCoord.xy - .5*iResolution.xy)/iResolution.y;

      float w = mix(
          sin(abs(uvz.y)*5.*PI+abs(uvz.x)*5.*PI -PI/2.),
          sin(atan(uvz.x,uvz.y)*4.+length(uvz)*8.+sin(length(uvz)*10.)*2.*2.),
          smoothstep(0.,0.1,-uvz.y)
          );
      vec2 p = abs(uvz+w*.01);

      float sc = 20.;
      float blur = sc/iResolution.y;
  #if 0
      float d1 = step(.4, length(fract(uvz*sc)-.5));
      float d2 = step(.4, length(fract( p *sc)-.5));
  #else
      float d1 = smoothstep(.4-blur,.4+blur, length(fract(uvz*sc)-.5));
      float d2 = smoothstep(.4-blur,.4+blur, length(fract( p *sc)-.5));
  #endif


      vec3 green = vec3(0.0,1.0,0.0);
      vec3 white = vec3(1.0);
      vec3 black = vec3(0.0);
      vec3 blue  = vec3(0.0,0.0,1.0);

      vec3 col = mix(
          mix(green, white, d1),
          mix(black,  blue,  d1),
          d2
          );

      // Output to screen
      fragColor = vec4(col,1.0);
  }
#+END_SRC

#+RESULTS: peripheral drift 2
[[file:./static/peripheral-drift-2.png]]

*** Throbert

Lots of album covers use this kind of throbbing effect

#+NAME: peripheral drift 3
#+BEGIN_SRC glsl :file ./static/peripheral-drift-3.png :width 1000 :height 1000 :exports both
  #define PI (355./113.)

  void main()
  {
      vec2 uv = (gl_FragCoord.xy - .5*iResolution.xy)/iResolution.y;

      float a = atan(uv.x,uv.y);
      vec3 col = cos(
          vec3(0.,.75,1.5)
          +(sin(a*8.)*PI+length(uv)*PI*16.*1.)
          * sin(a*8.+PI/2.)
          )*.5+.5;

      // Output to screen
      fragColor = vec4(col,1.0);
  }
#+END_SRC

#+RESULTS: peripheral drift 3
[[file:./static/peripheral-drift-3.png]]
